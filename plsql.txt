(P10)
Trigger: Write a after trigger for Insert, update and delete event 
considering following requirement: 
Emp(Emp_no, Emp_name, Emp_salary) 
a) Trigger should be initiated when salary tried to be inserted 
is less than Rs.50,000/- 
b) Trigger should be initiated when salary tried to be updated 
for value less than Rs. 50,000/- 
Also the new values expected to be inserted will be stored in new 
table Tracking(Emp_no,Emp_salary). 

create table tracking(emp_no,Emp_salary);
CREATE TABLE Emp (Emp_no NUMBER PRIMARY KEY,Emp_name VARCHAR2(50),Emp_salary NUMBER );

CREATE OR REPLACE TRIGGER trg_name
AFTER INSERT OR UPDATE OR DELETE ON emp
FOR EACH ROW
DECLARE
BEGIN
    IF INSERTING OR UPDATING THEN
        IF :NEW.emp_salary < 50000 THEN
            INSERT INTO tracking (emp_no, emp_salary)
            VALUES (:NEW.emp_no, :NEW.emp_salary);
        END IF;
    END IF;
END;
/

INSERT INTO emp (emp_no, emp_name, emp_salary) VALUES (1, 'ram', 45000);

SELECT * FROM tracking;

INSERT INTO emp (emp_no, emp_name, emp_salary) VALUES (2, 'Bob', 60000);
UPDATE emp SET emp_salary = 55000 WHERE emp_no = 1;

SELECT * FROM tracking;



----------------------------------------------------------------

(P1)
Write a PL/SQL code block to calculate the area of a circle for a 
value of radius varying from 5 to 9. Store the radius and the 
corresponding values of calculated area in an empty table named 
areas, consisting of two columns, radius and area.

create table areas(radius number, area number);

DECLARE
   radius_value NUMBER;
   area_value NUMBER;
BEGIN
   FOR radius_value IN 5..9 LOOP
      area_value := 3.14159 * radius_value * radius_value;

      INSERT INTO areas (radius, area)
      VALUES (radius_value, area_value);
   END LOOP;
   COMMIT;
END;
/

SELECT * FROM areas;

SELECT COUNT(*) FROM areas;

------------------------------------------------------------------------
(P3)
Write a PL/SQL block of code using Cursor that will merge the data 
available in the newly created table N_Roll Call with the data 
available in the table O_RollCall. If the data in the first table 
already exist in the second table, then that data should be 
skipped. 

create table N_Roll(student_id number,student_name VARCHAR(50),roll_call_time number);

create table O_Roll(student_id number,student_name VARCHAR(50),roll_call_time number);

DECLARE
   -- Declare a cursor to fetch data from N_Roll table
   CURSOR n_rollcall IS
       SELECT student_id, student_name, roll_call_time
       FROM n_roll;
   
   -- Declare variables to hold the data fetched from the cursor
   v_student_id n_roll.student_id%TYPE;
   v_student_name n_roll.student_name%TYPE;
   v_roll_call_time n_roll.roll_call_time%TYPE;
BEGIN
   
   FOR record IN n_rollcall LOOP
      
      v_student_id := record.student_id;
      v_student_name := record.student_name;
      v_roll_call_time := record.roll_call_time;

      -- Debug output to verify values
      DBMS_OUTPUT.PUT_LINE('Processing: ' || v_student_name || ' with ID: ' || v_student_id);

      -- Check if the data already exists in O_Roll
      BEGIN
         -- Try to select the record into a variable, if it exists, an exception will be raised
         SELECT 1
         INTO v_student_id
         FROM O_Roll
         WHERE student_id = v_student_id
         AND roll_call_time = v_roll_call_time;

      END;
   END LOOP;

   -- Commit the transaction to apply the changes
   COMMIT;

   -- Output success message
   DBMS_OUTPUT.PUT_LINE('Data merged successfully.');
END;
/

INSERT INTO N_Roll (student_id, student_name, roll_call_time) VALUES (1, 'John Doe', 101);
INSERT INTO N_Roll (student_id, student_name, roll_call_time) VALUES (2, 'Jane Smith', 102);
INSERT INTO N_Roll (student_id, student_name, roll_call_time) VALUES (3, 'Alice Johnson', 103);


SET SERVEROUTPUT ON;

SELECT * FROM O_Roll;

------------------------------------------------------------------------

(P8)
Write a Row Level Before and After Trigger on Library table. The 
System should keep track of the records that are being updated or 
deleted. The old value of updated or deleted records should be 
added in Library_Audit table. 


-- Create Library table
CREATE TABLE Library (
    book_id NUMBER PRIMARY KEY,
    title VARCHAR2(50)
);

-- Create Library_Tracking table for tracking changes
CREATE TABLE Library_Tracking (
    tracking_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    book_id NUMBER,
    title VARCHAR2(50),
    action_type VARCHAR2(20),
    action_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insert test data into Library table
INSERT INTO Library (book_id, title) VALUES (1, '1984');
INSERT INTO Library (book_id, title) VALUES (2, 'To Kill a Mockingbird');

-- Update a record to trigger the AFTER UPDATE trigger
UPDATE Library SET title = 'Animal Farm' WHERE book_id = 1;

-- Delete a record to trigger the BEFORE DELETE trigger
DELETE FROM Library WHERE book_id = 2;

-- Check the tracking table for recorded actions
SELECT * FROM Library_Tracking;


------------------------------------------------------------------------
(P9)
Trigger: Create a row level trigger for the CUSTOMERS table that 
would fire INSERT or UPDATE or DELETE operations performed on the 
CUSTOMERS table. This trigger will display the salary difference 
between the old values and new values. 

CREATE TABLE CUSTOMERS (
    customer_id NUMBER PRIMARY KEY,
    name VARCHAR2(50),
    salary NUMBER
);


CREATE OR REPLACE TRIGGER customers_salary_diff
AFTER INSERT OR UPDATE OR DELETE ON CUSTOMERS
FOR EACH ROW
BEGIN
   IF INSERTING THEN
      DBMS_OUTPUT.PUT_LINE('New salary inserted: ' || :NEW.salary);
   
   ELSIF UPDATING THEN
      IF :OLD.salary IS NOT NULL AND :NEW.salary IS NOT NULL THEN
         DBMS_OUTPUT.PUT_LINE('Salary updated.');
         DBMS_OUTPUT.PUT_LINE('Old Salary: ' || :OLD.salary || 
                              ', New Salary: ' || :NEW.salary || 
                              ', Difference: ' || (:NEW.salary - :OLD.salary));
      END IF;
   
   ELSIF DELETING THEN
      DBMS_OUTPUT.PUT_LINE('Salary deleted: ' || :OLD.salary);
   END IF;
END;
/

-- Insert a new customer
INSERT INTO CUSTOMERS (customer_id, name, salary) VALUES (1, 'mukesh', 50000);

-- Update the salary of the customer
UPDATE CUSTOMERS SET salary = 55000 WHERE customer_id = 1;

-- Delete the customer record
DELETE FROM CUSTOMERS WHERE customer_id = 1;



-------------------------------------------------------------------------
(P5)
Write a PL/SQL Block to increase the salary of employees by 10% of 
existing salary, who are having salary less than average salary of 
organization, whenever such salary updates take place, a record for 
same is maintained in the increment_salary table. 
emp(emp_no, salary) 
increment_salary(emp_no, salary)



-- Create the emp table
CREATE TABLE emp1 (
    emp_no NUMBER PRIMARY KEY,
    salary NUMBER
);

-- Create the increment_salary table
CREATE TABLE increment_salary (
    emp_no NUMBER,
    salary NUMBER
);


DECLARE
   v_avg_salary NUMBER;
   v_new_salary NUMBER;
BEGIN
   -- Calculate the average salary of the organization from emp1 table
   SELECT AVG(salary) INTO v_avg_salary FROM emp1;

   -- Loop through employees in emp1 with salaries below the average
   FOR emp_rec IN (SELECT emp_no, salary FROM emp1 WHERE salary < v_avg_salary) LOOP
      -- Calculate the new salary (increase by 10%)
      v_new_salary := emp_rec.salary * 1.10;

      -- Increase salary in emp1 table
      UPDATE emp1
      SET salary = v_new_salary
      WHERE emp_no = emp_rec.emp_no;

      -- Insert the updated salary into the increment_salary table
      INSERT INTO increment_salary (emp_no, salary)
      VALUES (emp_rec.emp_no, v_new_salary);
   END LOOP;

   COMMIT;  -- Save the changes
   DBMS_OUTPUT.PUT_LINE('Salaries updated successfully for employees below average salary.');
END;
/

SELECT * FROM emp1;  -- Check if salaries are updated

SELECT * FROM increment_salary;  -- Check if salary increments are logged


------------------------------------------------------------------------
(P4)
Write a PL/SQL block for following requirements and handle the 
exceptions. Roll no. of students will be entered by the user. 
Attendance of roll no. entered by user will be checked in the Stud 
table. If attendance is less than 75% then display the message 
“Term not granted” and set the status in stud table as “Detained”. 
Otherwise display message “Term granted” and set the status in stud 
table as “Not Detained”. Student (Roll, Name, Attendance, Status)


CREATE TABLE stud (
    roll NUMBER PRIMARY KEY,         -- Roll number (unique for each student)
    name VARCHAR2(100),              -- Student's name
    attendance NUMBER,               -- Attendance percentage
    status VARCHAR2(20)              -- Status ('Detained' or 'Not Detained')
);

INSERT INTO stud (roll, name, attendance, status) 
VALUES (1, 'prajakta', 80, 'Not Detained');

INSERT INTO stud (roll, name, attendance, status) 
VALUES (2, 'mukesh', 70, 'Not Detained');

INSERT INTO stud (roll, name, attendance, status) 
VALUES (3, 'sukesh', 85, 'Not Detained');

INSERT INTO stud (roll, name, attendance, status) 
VALUES (4, 'rajesh', 60, 'Not Detained');

COMMIT;

DECLARE
    v_roll_no STUD.roll%TYPE;            -- Variable for roll number
    v_attendance STUD.attendance%TYPE;   -- Variable for attendance
BEGIN
    -- Take roll number input from the user (For testing, you can replace this with an actual input method)
    v_roll_no := &roll_no;  -- Replace with actual input or bind variable

    -- Fetch attendance for the given roll number
    SELECT attendance INTO v_attendance
    FROM stud
    WHERE roll = v_roll_no;

    -- Check if attendance is less than 75%
    IF v_attendance < 75 THEN
        -- If attendance is less than 75%, set status to 'Detained'
        UPDATE stud
        SET status = 'Detained'
        WHERE roll = v_roll_no;
        DBMS_OUTPUT.PUT_LINE('Term not granted');  -- Message for detained students
    ELSE
        -- If attendance is 75% or more, set status to 'Not Detained'
        UPDATE stud
        SET status = 'Not Detained'
        WHERE roll = v_roll_no;
        DBMS_OUTPUT.PUT_LINE('Term granted');  -- Message for non-detained students
    END IF;

    -- Commit the changes
    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        -- If no student found with the entered roll number
        DBMS_OUTPUT.PUT_LINE('No student found with the given roll number.');
    WHEN OTHERS THEN
        -- For any other error, display error message and rollback changes
        DBMS_OUTPUT.PUT_LINE('An unexpected error occurred: ' || SQLERRM);
        ROLLBACK;
END;
/



-------------------------------------------------------------------
(P7)
Create a stored function titled 'Age_calc'. 
Accept the date of birth of a person as a parameter. 
Calculate the age of the person in years, months and days e.g. 3 
years, 2months, 10 days. 
Return the age in years directly (with the help of Return 
statement). The months and days are to be returned indirectly in 
the form of OUT parameters. 


-- Create the table to store person information
CREATE TABLE persons (
    person_id NUMBER PRIMARY KEY,      -- Unique ID for each person
    name VARCHAR2(100),                -- Name of the person
    date_of_birth DATE                 -- Date of birth of the person
);

CREATE OR REPLACE FUNCTION Age_calc (
    p_dob IN DATE,                -- Input: Date of birth
    p_months OUT NUMBER,          -- Output: Number of months (OUT parameter)
    p_days OUT NUMBER             -- Output: Number of days (OUT parameter)
) RETURN NUMBER IS
    v_today DATE := SYSDATE;     -- Today's date
    v_years NUMBER;              -- Variable to hold calculated years
    v_month_diff NUMBER;         -- Variable for month difference
    v_day_diff NUMBER;           -- Variable for day difference
BEGIN
    -- Calculate the number of years between today's date and date of birth
    v_years := TRUNC(MONTHS_BETWEEN(v_today, p_dob) / 12);

    -- Calculate the number of months remaining after subtracting full years
    v_month_diff := TRUNC(MONTHS_BETWEEN(v_today, p_dob) - (v_years * 12));

    -- Calculate the number of days remaining after full months
    v_day_diff := v_today - ADD_MONTHS(p_dob, v_years * 12 + v_month_diff);

    -- Assign values to the OUT parameters
    p_months := v_month_diff;
    p_days := v_day_diff;

    -- Return the age in years
    RETURN v_years;

EXCEPTION
    WHEN OTHERS THEN
        -- Handle any unexpected errors
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
        RETURN NULL;
END;
/

-- Insert sample data into the persons table
INSERT INTO persons (person_id, name, date_of_birth) 
VALUES (1, 'John Doe', TO_DATE('1990-05-15', 'YYYY-MM-DD'));

INSERT INTO persons (person_id, name, date_of_birth) 
VALUES (2, 'Alice Smith', TO_DATE('1985-10-30', 'YYYY-MM-DD'));

INSERT INTO persons (person_id, name, date_of_birth) 
VALUES (3, 'Bob Johnson', TO_DATE('2000-01-25', 'YYYY-MM-DD'));

-- Commit the changes
COMMIT;

DECLARE
    v_age_in_years NUMBER;    -- Variable to hold age in years
    v_months NUMBER;          -- Variable to hold months
    v_days NUMBER;            -- Variable to hold days
    v_dob DATE;               -- Variable to store the date of birth
BEGIN
    -- Retrieve the date of birth for John Doe
    SELECT date_of_birth
    INTO v_dob
    FROM persons
    WHERE person_id = 1;

    -- Call the Age_calc function with the retrieved date of birth
    v_age_in_years := Age_calc(v_dob, v_months, v_days);

    -- Output the result
    DBMS_OUTPUT.PUT_LINE('Age of John Doe: ' || v_age_in_years || ' years, ' || v_months || ' months, ' || v_days || ' days');
END;
/



--------------------------------------------------------------------------------

(P6)
Write a Stored Procedure namely proc_Grade for the categorization 
of student. If marks scored by students in examination is <=1500 
and marks>=990 then student will be placed in distinction category 
if marks scored are between 989 and 900 categories is first class, 
if marks 899 and 825 category is Higher Second Class. 
Write a PL/SQL block for using procedure created with above 
requirement. 
Stud_Marks(name, total_marks),  
Result (Roll,Name, Class)

-- Create the Stud_Marks table to store student names and total marks
CREATE TABLE Stud_Marks (
    name VARCHAR2(100),
    total_marks NUMBER
);

-- Create the Result table to store student roll number, name, and their class
CREATE TABLE Result (
    roll NUMBER PRIMARY KEY,
    name VARCHAR2(100),
    class VARCHAR2(50)
);

CREATE OR REPLACE PROCEDURE proc_Grade (
    p_name IN VARCHAR2,           -- Name of the student
    p_total_marks IN NUMBER       -- Total marks of the student
)
IS
    v_class VARCHAR2(50);         -- Variable to store the class category
BEGIN
    -- Categorize the student based on total marks
    IF p_total_marks >= 990 AND p_total_marks <= 1500 THEN
        v_class := 'Distinction';
    ELSIF p_total_marks >= 900 AND p_total_marks <= 989 THEN
        v_class := 'First Class';
    ELSIF p_total_marks >= 825 AND p_total_marks <= 899 THEN
        v_class := 'Higher Second Class';
    ELSE
        v_class := 'Not Categorized'; -- Case where marks are below 825
    END IF;

    -- Insert the result into the Result table
    INSERT INTO Result (roll, name, class)
    VALUES (Result_seq.NEXTVAL, p_name, v_class);

    COMMIT; -- Commit the transaction
END proc_Grade;
/

CREATE SEQUENCE Result_seq
START WITH 1
INCREMENT BY 1
NOCACHE;

DECLARE
    v_name VARCHAR2(100);
    v_total_marks NUMBER;
BEGIN
    -- Example: Adding student data and calling the procedure
    v_name := 'John Doe';
    v_total_marks := 1250;
    -- Call the procedure to categorize the student
    proc_Grade(v_name, v_total_marks);

    v_name := 'Jane Smith';
    v_total_marks := 950;
    -- Call the procedure again for another student
    proc_Grade(v_name, v_total_marks);

    -- You can add more students here as needed
    DBMS_OUTPUT.PUT_LINE('Grades have been successfully categorized for the students.');
END;
/

SELECT * FROM Result;


---------------------------------------------------------------------------------

(P2)
Write an Unnamed PL/SQL of code for the following requirements: - 
Schema: 
   Borrower (Rollin, Name, DateofIssue, NameofBook, Status) 
   Fine (Roll_no,Date,Amt) 
Accept roll_no & name of book from user. 
Check the number of days (from date of issue). 
1. If days are between 15 to 30 then fine amounts will be Rs 5 per 
day. 
2. If no. of days>30, per day fine will be Rs 50 per day & for days 
less than 30, Rs. 5 per day. 
3. After submitting the book, status will change from I to R. 
4. If condition of fine is true, then details will be stored into 
fine table.

DECLARE
    v_roll_no NUMBER;                  -- Variable to store roll number
    v_name_of_book VARCHAR2(100);       -- Variable to store name of the book
    v_date_of_issue DATE;               -- Variable to store the date of issue
    v_current_date DATE := SYSDATE;     -- Get the current date
    v_days_diff NUMBER;                 -- Variable to store the difference in days
    v_fine_amt NUMBER := 0;             -- Variable to store calculated fine amount
BEGIN
    -- Accept the roll number and name of book from the user
    v_roll_no := &roll_no;             -- User input for roll number
    v_name_of_book := '&name_of_book'; -- User input for name of the book

    -- Retrieve the DateofIssue from the Borrower table for the given roll_no and name_of_book
    SELECT DateofIssue INTO v_date_of_issue
    FROM Borrower
    WHERE Rollin = v_roll_no AND NameofBook = v_name_of_book;

    -- Calculate the number of days between the current date and the DateofIssue
    v_days_diff := (v_current_date - v_date_of_issue);

    -- Fine calculation based on the number of days
    IF v_days_diff BETWEEN 15 AND 30 THEN
        v_fine_amt := v_days_diff * 5;  -- Rs 5 per day if days are between 15 and 30
    ELSIF v_days_diff > 30 THEN
        v_fine_amt := (30 * 5) + ((v_days_diff - 30) * 50);  -- Rs 5 per day for first 30 days, Rs 50 per day for days > 30
    END IF;

    -- Update the Borrower table status from 'I' (Issued) to 'R' (Returned)
    UPDATE Borrower
    SET Status = 'R'
    WHERE Rollin = v_roll_no AND NameofBook = v_name_of_book;

    -- If a fine is calculated, insert the fine details into the Fine table
    IF v_fine_amt > 0 THEN
        INSERT INTO Fine (Roll_no, Date, Amt)
        VALUES (v_roll_no, v_current_date, v_fine_amt);
    END IF;

    COMMIT;  -- Commit the transaction

    -- Output message
    DBMS_OUTPUT.PUT_LINE('Book returned successfully. Fine: Rs ' || v_fine_amt);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No records found for the given roll number and book name.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END;
/

-- Inserting data into Borrower table
INSERT INTO Borrower (Rollin, Name, DateofIssue, NameofBook, Status)
VALUES (101, 'John Doe', TO_DATE('2024-09-01', 'YYYY-MM-DD'), 'Advanced Java', 'I');

INSERT INTO Borrower (Rollin, Name, DateofIssue, NameofBook, Status)
VALUES (102, 'Jane Smith', TO_DATE('2024-08-01', 'YYYY-MM-DD'), 'Data Structures', 'I');

INSERT INTO Borrower (Rollin, Name, DateofIssue, NameofBook, Status)
VALUES (103, 'Alice Johnson', TO_DATE('2024-07-15', 'YYYY-MM-DD'), 'Database Management', 'I');

-- Commit the changes
COMMIT;

------------------------------------------------------------------------------